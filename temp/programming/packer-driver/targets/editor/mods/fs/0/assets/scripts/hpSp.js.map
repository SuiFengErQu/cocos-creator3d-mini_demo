{"version":3,"sources":["file:///D:/CocosProject/testDemo/cocos3d20211013/20211014/demolist2/assets/scripts/hpSp.ts"],"names":["_decorator","Component","Node","Vec3","CameraComponent","geometry","systemEvent","SystemEvent","PhysicsSystem","ParticleSystem","Quat","tween","SkeletalAnimation","ccclass","property","HpSp","start","node","getComponent","play","ray","Ray","on","EventType","TOUCH_END","touchEnd","e","ca","camerr","screenPointToRay","getLocationX","getLocationY","instance","raycast","arr","raycastResults","i","length","collider","name","par","worldPosition","hitPoint","finishPos","qut","qut1","qutStart","rotation","dir","subtract","fromViewUp","normalize","tw","to","onUpdate","target","ratio","set","slerp","setRotation","call","move","update","deltaTime","useLerpMove","lerpFinishPos","position","x","y","z","end","ve","lerp","translate","multiplyScalar","moveSpeed","dis","distance","uiHp","parent","getWorldPosition","convertToUINode","hp3dNode","setPosition","scale"],"mappings":"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","sourcesContent":["\nimport { _decorator, Component, Node, Vec3, CameraComponent, geometry, systemEvent, SystemEvent, PhysicsSystem, ParticleSystem, math, quat, Quat, tween, SkeletalAnimation, ConstantForce, RigidBody } from 'cc';\nconst { ccclass, property } = _decorator;\n\n/**\n * Predefined variables\n * Name = HpSp\n * DateTime = Fri Oct 29 2021 16:10:01 GMT+0800 (中国标准时间)\n * Author = fywxk\n * FileBasename = hpSp.ts\n * FileBasenameNoExtension = hpSp\n * URL = db://assets/scripts/hpSp.ts\n * ManualUrl = https://docs.cocos.com/creator/3.3/manual/zh/\n *\n */\n\n@ccclass('HpSp')\nexport class HpSp extends Component {\n    // [1]\n    // dummy = '';\n\n    // [2]\n    // @property\n    // serializableDummy = 0;\n\n    @property(Node)\n    uiHp: Node = null; // UI\n\n    @property(Node)\n    hp3dNode: Node = null; // 3d 血条挂点\n\n    @property(Node)\n    camerr: Node = null;\n\n    @property(ParticleSystem)\n    par: ParticleSystem = null;\n\n\n    @property(Node)\n    cube: Node = null;\n\n    useLerpMove = true;// 是否使用插值移动\n    move = false;// 是否可以移动\n    lerpFinishPos = null;// 插值的终点\n    finishPos = new Vec3(0, 0, 0);// 终点坐标\n    moveSpeed = 20;\n\n    ray: geometry.Ray = null;\n    start() {\n        // [3]\n        // 先播放idle动画\n        this.node.getComponent(SkeletalAnimation).play(\"cocos_anim_idle\")\n        this.ray = new geometry.Ray();\n\n        systemEvent.on(SystemEvent.EventType.TOUCH_END, this.touchEnd, this)\n    }\n    touchEnd(e) {\n        // 射线检测碰撞\n        let ca = this.camerr.getComponent(CameraComponent);\n        ca.screenPointToRay(e.getLocationX(), e.getLocationY(), this.ray);\n        if (PhysicsSystem.instance.raycast(this.ray)) {\n            let arr = PhysicsSystem.instance.raycastResults;\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i].collider.node.name == \"Terrain\") {\n                    // console.log(\"碰撞到地面\",arr[i].hitPoint);\n                    this.par.play();\n                    this.par.node.worldPosition = arr[i].hitPoint;// 粒子位置直接设置过去\n                    this.finishPos = arr[i].hitPoint;\n                    const qut = new Quat();\n                    const qut1 = new Quat();\n                    const qutStart = this.node.rotation\n                    const dir = arr[i].hitPoint.subtract(this.node.worldPosition);// 求出到目标点的方向向量\n                    Quat.fromViewUp(qut, dir.normalize(), new Vec3(0, 1, 0))// 计算出目标点的四元数\n                    // tween实现旋转\n                    const tw = tween(this.node);\n                    tw.to(0.2, {}, {\n                        onUpdate: (target, ratio: number) => {\n                            // ratio : 0~1\n                            // 这里使用球面插值，旋转时不会出现变形\n                            qut1.set(qutStart).slerp(qut, ratio)\n                            this.node.setRotation(qut1);\n                        },\n                    }).call(() => {\n                        // 通过translate移动\n                        this.move = true;\n                        // 播放跑的动画\n                        this.node.getComponent(SkeletalAnimation).play(\"cocos_anim_run\")\n                    })\n                    tw.start();\n\n\n                }\n            }\n        }\n    }\n    update(deltaTime: number) {\n        // 开始移动\n        if (this.move) {\n            if (this.useLerpMove) {// 通知插值移动\n                // 1. 插值移动到目标点，更有真实性\n                if (!this.lerpFinishPos) {\n                    let start = new Vec3(this.node.position.x, this.node.position.y, this.node.position.z);\n                    let end = new Vec3(this.par.node.worldPosition.x, this.node.position.y, this.par.node.worldPosition.z)\n                    let ve = new Vec3(0, 0, 0)// 插值后终点\n                    Vec3.lerp(ve, start, end, 0.5);// 每次终点取起点和终点的中间值\n                    this.lerpFinishPos = ve;\n                }\n                else\n                {// 判断是否移动到插值终点\n                    this.node.translate(new Vec3(0, 0, 1).multiplyScalar(deltaTime * this.moveSpeed));\n                    let dis = Vec3.distance(this.node.position, this.lerpFinishPos)\n                    if (dis <= 0.2) {\n                        this.lerpFinishPos = null;// 清空下次继续找中间点\n                    }\n                }\n            }\n            else {     // 2. 通过translate移动到目标点,效果不够真实圆滑\n                this.node.translate(new Vec3(0, 0, 1).multiplyScalar(deltaTime * this.moveSpeed)); // 旋转后 想对于自己本地坐标想自己的前方移动\n            }\n\n\n            // 判断距离终点距离\n            let dis = Vec3.distance(this.node.position, this.par.node.position)\n            if (dis <= 0.2) {\n                this.move = false;\n                this.node.getComponent(SkeletalAnimation).play(\"cocos_anim_idle\")\n            }\n        }\n        // 血条跟随\n        let ve = new Vec3(0, 0, 0)\n        this.uiHp.parent.getWorldPosition(ve);\n        let ca = this.camerr.getComponent(CameraComponent);\n        ca.convertToUINode(this.hp3dNode.worldPosition, this.uiHp.parent, ve);\n        this.uiHp.setPosition(ve)\n        // 血条近大远小的效果\n        let dis = Vec3.distance(this.node.worldPosition, this.camerr.worldPosition);\n        if (dis > 10) {\n            this.uiHp.scale = new Vec3(0.06 * (100 / (dis - 10)), 0.06 * (100 / (dis - 10)), 1)\n\n        }\n\n\n        //   let qu = math.quat()\n        //   this.cube.rotate(math.Quat.rotateAround( math.quat(), math.quat(), this.cube.position,0.001))\n    }\n}\n\n/**\n * [1] Class member could be defined like this.\n * [2] Use `property` decorator if your want the member to be serializable.\n * [3] Your initialization goes here.\n * [4] Your update function goes here.\n *\n * Learn more about scripting: https://docs.cocos.com/creator/3.3/manual/zh/scripting/\n * Learn more about CCClass: https://docs.cocos.com/creator/3.3/manual/zh/scripting/ccclass.html\n * Learn more about life-cycle callbacks: https://docs.cocos.com/creator/3.3/manual/zh/scripting/life-cycle-callbacks.html\n */\n"]}